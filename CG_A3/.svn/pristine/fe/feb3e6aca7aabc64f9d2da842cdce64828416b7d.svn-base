#include "ShadowMap.h"

using namespace Rendering;
using namespace MultiPass;

ShadowMap::ShadowMap()
{
}


ShadowMap::~ShadowMap()
{
}


bool ShadowMap::Create()
{
	glUseProgram(m_shader);
	glm::vec3 lightInvDir = glm::vec3(544, 378, -120);

	// Compute the MVP matrix from the light's point of view
	glm::mat4 depthProjectionMatrix = glm::ortho<float>(-1000, 1000, -1000, 1000, -1000, 1000);
	glm::mat4 depthViewMatrix = glm::lookAt(lightInvDir, glm::vec3(0, 0, 0), glm::vec3(0, 1, 0));
	glm::mat4 depthModelMatrix = glm::mat4(1.0);
	m_depthMVP = depthProjectionMatrix * depthViewMatrix * depthModelMatrix;

	glm::mat4 biasMatrix(
		0.5, 0.0, 0.0, 0.0,
		0.0, 0.5, 0.0, 0.0,
		0.0, 0.0, 0.5, 0.0,
		0.5, 0.5, 0.5, 1.0
		);
	m_depthBiasMVP = biasMatrix*m_depthMVP;

	// Send our transformation to the currently bound shader,
	// in the "MVP" uniform
	GLuint depthMatrixID = glGetUniformLocation(m_shader, "depthMVP");
	glUniformMatrix4fv(depthMatrixID, 1, GL_FALSE, &m_depthMVP[0][0]);
	GLuint depthBiasMatID = glGetUniformLocation(m_shader, "depthBiasMVP");
	glUniformMatrix4fv(depthBiasMatID, 1, GL_FALSE, &m_depthBiasMVP[0][0]);

	// The framebuffer, which regroups 0, 1, or more textures, and 0 or 1 depth buffer.
	GLuint FramebufferName = 0;
	glGenFramebuffers(1, &FramebufferName);
	glBindFramebuffer(GL_FRAMEBUFFER, FramebufferName);

	// Depth texture. Slower than a depth buffer, but you can sample it later in your shader
	GLuint depthTexture;
	glGenTextures(1, &depthTexture);
	glBindTexture(GL_TEXTURE_2D, depthTexture);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT16, 1024, 1024, 0, GL_DEPTH_COMPONENT, GL_FLOAT, 0);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

	glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthTexture, 0);

	glDrawBuffer(GL_NONE); // No color buffer is drawn to.

	// Always check that our framebuffer is ok
	if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
		return false;
	return true;

	Draw();

	// Render to the screen
	glBindFramebuffer(GL_FRAMEBUFFER, 0);
	glViewport(0, 0, 1024, 768); // Render on the whole framebuffer, complete from the lower left corner to the upper right

	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK); // Cull back-facing triangles -> draw only front-facing triangles

	// Clear the screen
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
}

void ShadowMap::Draw()
{
	glUseProgram(m_shader);
	for (int i = 0; i < m_vao.size(); i++)
	{
		glBindVertexArray(m_vao[i]);
		glDrawElements(GL_TRIANGLES,
			m_indiciesLength[i],
			GL_UNSIGNED_INT,
			(void*)0);
	}
	glBindVertexArray(0);
}

void ShadowMap::addSceneData(vector<GLuint>& vao, vector<unsigned int>& idx_len)
{
	for (int i = 0; i < vao.size(); i++)
	{
		m_vao.push_back(vao[i]);
	}
	for (int i = 0; i < idx_len.size(); i++)
	{
		m_indiciesLength.push_back(idx_len[i]);
	}
}
